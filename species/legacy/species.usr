      include "lineplot.f"
c-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,eg) ! set variable properties
      implicit none
      integer ix,iy,iz,eg,e
     
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'SPECIES'

      real Re, We, Fr, rhoratio, muratio
      real udim, charl, rhol, mul, gdim, gamm
      real nul, nug
      real rhog,mug
      real psi
      integer icalld
      save icalld
      data icalld /0/

      common /dimen/ Re,We,Fr
      real Sc

      common /scales/ t0
      real t0

      e = gllel(eg)

!     These routine is not called by external solver
!     To Do: change the flow, so that this routine is called
!     similar to RANS. Will avoid confusion

      charl = 0.01
      gdim = 9.81
      rhol = 998.2
      rhog = 1.122
      mul = 1e-3
      mug = 1.824e-5 !/5.0

      diffl = 0.2 * 1e-4
      diffg = 1.0 * 1e-4

      udim = diffl / charl !diffusive scaling
      t0 = charl/udim

      Sc = mul/rhol/diffl  !Schmidt number
      He = 3.0             !Henry law He=cg/cl

      diffg = diffg/diffl
      diffl = diffl/diffl

      Re = rhol*udim*charl/mul
      Pe = Re * Sc
      Fr = udim**2.0/(gdim*charl)
      gamm = 0.06
      We = charl*rhol*udim**2.0/gamm

      psi = t(ix,iy,iz,e,1)
      psi = max(0.0,psi)
      psi = min(1.0,psi)
      if(ifield.eq.1)then
        utrans = ((1.0-psi)*rhog + psi*rhol)/rhol
        udiff = ((1.0-psi)*mug + psi*mul)/mul/Re
      elseif(ifield.eq.3)then
        utrans = 1.0
        udiff = ((1.0-psi)*diffg + psi*diffl)/Pe
      else
        utrans = 1.0
        udiff = 1e-10
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userf(ix,iy,iz,eg) ! set acceleration term
      implicit none
      integer ix,iy,iz,eg,e

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      common /dimen/ Re,We,Fr
      real Re,We,Fr
      real sfx,sfy,sfz

      real svvx,svvy,svvz

      e = gllel(eg)

      sfx = 0.0
      sfy = 0.0
      sfz = 0.0
      svvx = 0.0
      svvy = 0.0
      svvz = 0.0

      ffx = sfx + svvx
      ffy = sfy -1./Fr + svvy
      ffz = sfz

      return
      end
c-----------------------------------------------------------------------
      subroutine userq(ix,iy,iz,eg) ! set source term
      implicit none
      integer ix,iy,iz,eg,e

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'SPECIES'
      
      real speciesSrc

      e = gllel(eg)
      
      qvol = 0.0
      avol = 0.0

      if(ifield.eq.3)then
        qvol = speciesSrc(ix,iy,iz,e)/Pe
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc(ix,iy,iz,iside,eg) ! set up boundary conditions
      implicit none
      integer ix,iy,iz,iside,eg

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e
      real yplus

      e = gllel(eg)

      ux   = 0.0
      uy   = 0.0
      uz   = 0.0
      temp = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric(ix,iy,iz,eg) ! set up initial conditions
      implicit none
      integer ix,iy,iz,eg,e

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      real xx,yy,heaviside
      real phix,phiy
      real eps

      e = gllel(eg)

      xx = xm1(ix,iy,iz,e)
      yy = ym1(ix,iy,iz,e)

      ux = 0.0
      uy = 0.0
      uz = 0.0

      phiy = 0.5 - yy
      temp = phiy
      eps = 1.0/(lx1-1.0)
      temp = heaviside(ix,iy,iz,e,temp,eps)
      
      return
      end
c-----------------------------------------------------------------------
      subroutine userchk()
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real pta(3),ptb(3)

      integer ntot,i

      real plttime(4)
      integer plti
      save plti 
      data plti /1/

      common /scales/ t0
      real t0

      ntot = lx1*ly1*lz1*nelv

      plttime(1) = 0.0
      plttime(2) = 0.05 !* 0.75
      plttime(3) = 0.2 !* 0.75
      plttime(4) = 0.8 !* 0.75

      if(time * t0 .ge. plttime(plti) .and. plti.le.4)then
        pta(1) = 0.5
        pta(2) = 0.0
        pta(3) = 0.0
        ptb(1) = 0.5
        ptb(2) = 1.0
        ptb(3) = 0.0

        call lineplot(pta,ptb,1001)

        plti = plti+1
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userqtl ! Set thermal divergence

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat()   ! This routine to modify element vertices
      implicit none

      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2()  ! This routine to modify mesh coordinates
      implicit none

      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3()
      implicit none

      include 'SIZE'
      include 'TOTAL'

      ifflow = .false.
      
      return
      end
c---------------------------------------------------------------------
      real function speciesSrc(ix,iy,iz,e)
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'SPECIES'

      integer ix,iy,iz,e

      common /sptemp/ stmp(lx1,ly1,lz1,lelv),
     $                delta(lx1,ly1,lz1,lelv),
     $                spx(lx1,ly1,lz1,lelv),
     $                spy(lx1,ly1,lz1,lelv), 
     $                spz(lx1,ly1,lz1,lelv) 
      real stmp, delta, spx, spy, spz
      real psi
      real term1, term2

      integer i,ntot

      ntot = lx1*ly1*lz1*nelt 

      if(ix*iy*iz*e .eq. 1)then
        do i=1,ntot
          psi = t(i,1,1,1,1)
          psi = max(0.0,psi)
          psi = min(1.0,psi)
          term1 = diffl - diffg
  
          term2 = (diffl - He*diffg)/(psi + He*(1.0-psi))
          stmp(i,1,1,1) = term1 - term2
        enddo
        call col2(stmp, t(1,1,1,1,2),ntot)

        call gradm1(spx,spy,spz,t(1,1,1,1,1))
        call opcolv(spx,spy,spz,bm1)
        call opdssum(spx,spy,spz)
        call opcolv(spx,spy,spz,binvm1)

        call col2(spx,stmp,ntot)
        call col2(spy,stmp,ntot)
        if(if3d)call col2(spz,stmp,ntot)

        call opdiv(spdiv,spx,spy,spz)
        call dssum(spdiv,lx1,ly1,lz1)
        call col2(spdiv,binvm1,ntot)
      endif

      speciesSrc = spdiv(ix,iy,iz,e)

      return
      end
c---------------------------------------------------------------
      real function heaviside(ix,iy,iz,iel,phi,epsin)
      implicit none
      include 'SIZE'
      include 'TOTAL'

      integer ix,iy,iz,iel

      real eps, deltael, phi, epsin

      eps = deltael(ix,iy,iz,iel)*epsin
      heaviside = 0.5*(tanh(phi/(2.0*eps))+1.0)

      return
      end
c---------------------------------------------------------------
      real function deltael(ix,iy,iz,iel)
      implicit none
      include 'SIZE'
      include 'TOTAL'

      integer ix,iy,iz,iel

      real dx(lx1,ly1,lz1,lelt)
      save dx 

      integer icalld
      data icalld /0/
      save icalld

      integer nedge
      parameter(nedge = 4 + 8*(ldim-2))
      real ledg(nedge)

      integer nxyz,n,ie
      real dd,dinv
      real dxmin_e
      real dxmax_e
      real dist_xyzc
      real vlmax
      real glsum, dxsum, glmax, glmin
      integer iglsum

      real delta_save
      save delta_save

      common /ellength/ dxmax, dxmin
      real dxmax, dxmin

      real dxave

      nxyz = nx1*ny1*nz1
      n    = nxyz*nelv

      if (icalld.eq.0 .or. ifmvbd) then
         dinv = 1./ldim
         do ie = 1,nelv
           ledg(1) = dist_xyzc(1,2,ie)
           ledg(2) = dist_xyzc(1,4,ie)
           ledg(3) = dist_xyzc(2,3,ie)
           ledg(4) = dist_xyzc(4,3,ie)
           if (ndim.eq.3) then
             ledg(5)  = dist_xyzc(1,5,ie)
             ledg(6)  = dist_xyzc(2,6,ie)
             ledg(7)  = dist_xyzc(4,8,ie)
             ledg(8)  = dist_xyzc(3,7,ie)

             ledg(9)  = dist_xyzc(5,6,ie)
             ledg(10) = dist_xyzc(5,8,ie)
             ledg(11) = dist_xyzc(8,7,ie)
             ledg(12) = dist_xyzc(6,7,ie)
           endif
            dd = vlmax(ledg,nedge)
            ! dd = dxmax_e(ie)
            call cfill(dx(1,1,1,ie),dd,nxyz) 
         enddo

         dxsum = glsum(dx,n)
         dxmax = glmax(dx,n)
         dxmin = glmin(dx,n)
        
         delta_save = dxsum/iglsum(n,1)

         dxave = delta_save

         if(nio.eq.0)then
           write(*,*)"Max/min/avg el length",dxmax,dxmin,dxave
         endif
         icalld = 1
      endif

      deltael = delta_save !dx(ix,iy,iz,iel)

      return
      end 
