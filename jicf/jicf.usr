      include "experimental/lvlSet.f"
      include "experimental/lserrors.f"
c-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,eg) ! set variable properties
      implicit none
      integer ix,iy,iz,eg,e
     
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'USRLS'
      include 'DIMENSION'

      real psi

      e = gllel(eg)

!     These routine is not called by external solver
!     To Do: change the flow, so that this routine is called
!     similar to RANS. Will avoid confusion

      charl = 1.0
      vell = 1.0
      qratio = 5.0

      Re = 5000.0
      We = 500.0

      rhoratio = 10.0
      rhol = 1.0
      rhog = rhol / rhoratio

      nul = charl * vell/Re
      mul = rhol * nul
      nuratio = 0.07
      muratio = nuratio * rhoratio
      mug = mul / muratio

      velg = sqrt(rhoratio * vell**2.0 / qratio)

      if(istep.eq.0 .and. nio.eq.0 .and. ix*iy*iz*e.eq.1)then
        write(*,*)"Reynolds number",Re
        write(*,*)"Weber number",We
        write(*,*)"rhol/rhog",rhoratio
        write(*,*)"mul/mug",muratio
        write(*,*)"nul/nug",nuratio
        write(*,*)"rhol,rhog",rhol,rhog
        write(*,*)"mul,mug",mul,mug
        write(*,*)"Mean injector vel",vell
        write(*,*)"Mean cross-flow vel",velg
        write(*,*)"q ratio",qratio
        write(*,*)"We crossflow",rhog*velg**2*charl*We
        write(*,*)"Re crossflow",rhog*velg*charl/mug
      endif

      if(ifield.eq.1)then
        psi = t(ix,iy,iz,e,ifld_cls-1)
        psi = max(0.0,psi)
        psi = min(1.0,psi)
        utrans = ((1.0-psi)*rhog + psi*rhol)/rhol
        udiff = ((1.0-psi)*mug + psi*mul)/mul/Re
        if(istep.le.2)then
          vtrans0(ix,iy,iz,e) = utrans
        else
          vtrans0(ix,iy,iz,e) = rhog/rhol
        endif
      else
        utrans = 1.0
        udiff = 1e-10
        if(ifavm(ifield-1))then
          udiff = 1e-10       !must be tiny for hyperbolic
        elseif(ifsvv(ifield-1))then
          udiff = 1e-10      !must be tiny for hyperbolic
        endif
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userf(ix,iy,iz,eg) ! set acceleration term
      implicit none
      integer ix,iy,iz,eg,e

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'DIMENSION'

      real sfx,sfy,sfz
      real svvx,svvy,svvz

      e = gllel(eg)

      !Note: gravity is not considered; Fr is infinite
      sfx = 0.0
      sfy = 0.0
      sfz = 0.0
      svvx = 0.0
      svvy = 0.0
      svvz = 0.0

      call surfacetension(ix,iy,iz,e,1./We,sfx,sfy,sfz)
      
      call svv_fluid(ix,iy,iz,e,svvx,svvy,svvz)

      ffx = sfx + svvx
      ffy = sfy + svvy
      ffz = sfz + svvz

      return
      end
c-----------------------------------------------------------------------
      subroutine userq(ix,iy,iz,eg) ! set source term
      implicit none
      integer ix,iy,iz,eg,e

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'USRLS'

      e = gllel(eg)
      
      qvol = 0.0
      avol = 0.0

      call limit_cls(ix,iy,iz,e)

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc(ix,iy,iz,iside,eg) ! set up boundary conditions
      implicit none
      integer ix,iy,iz,iside,eg

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'USRLS'
      include 'DIMENSION'

      integer e
      real xx,yy,zz,rad

      e = gllel(eg)

      ux   = 0.0
      uy   = 0.0
      uz   = 0.0
      temp = 0.0
      xx = xm1(ix,iy,iz,e)
      yy = ym1(ix,iy,iz,e)
      zz = zm1(ix,iy,iz,e)

      if(ifield.eq.1)then
        if(boundaryID(iside,e) .eq. 1) then !injector
          rad = sqrt(xx**2.0 + yy**2.0)
          uz = vell/0.817 * (1.0 - 2.0 * rad / 1.0)**(1.0/7.0)
        elseif(boundaryID(iside,e) .eq. 2) then !cross inlet
          ux = min(velg * time, velg)
        endif
      endif

      if(ifield.eq.ifld_cls .or. ifield.eq.ifld_clsr)then
        if(boundaryIDt(iside,e) .eq. 1) then !injector
          temp = 1.0
        elseif(boundaryIDt(iside,e) .eq. 2) then !cross inlet
          temp = 0.0
        elseif(boundaryIDt(iside,e) .eq. 3) then !sides
          temp = 0.0
        elseif(boundaryIDt(iside,e) .eq. 6) then !injector walls
          temp = 1.0
        endif
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine useric(ix,iy,iz,eg) ! set up initial conditions
      implicit none
      integer ix,iy,iz,eg,e

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'USRLS'
      include 'DIMENSION'

      real xx,yy,zz,heaviside
      real phix,phiy
      real rad

      e = gllel(eg)

      xx = xm1(ix,iy,iz,e)
      yy = ym1(ix,iy,iz,e)
      zz = zm1(ix,iy,iz,e)

      ux = 0.0
      uy = 0.0
      uz = 0.0
      temp = 0.0

      rad = sqrt(xx**2.0 + yy**2.0 + zz**2.0)

      if(zz.lt.0.0)then
        temp = 1.0
      elseif(zz.ge.0.0)then
        temp = 0.5 - rad
        temp = heaviside(ix,iy,iz,e,temp,0.0)
      endif

      ! if(zz.lt.0.0)then
      !   temp = -(zz + 1.0)
      !   temp = heaviside(ix,iy,iz,e,temp,0.0)
      ! endif

      ! if(ifield.eq.ifld_tls .or. ifield.eq.ifld_tlsr)then
      !   continue
      ! elseif(ifield.eq.ifld_cls .or. ifield.eq.ifld_clsr)then
      !   temp = heaviside(ix,iy,iz,e,temp,0.0)
      ! endif
      
      return
      end
c-----------------------------------------------------------------------
      subroutine userchk()
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'USRLS'

      real ntlsr, nclsr
      integer pord
      integer ncut

      pord = uparam(3)
      call extrappr(prext,pr,prlag(1,1,1,1,1),prlag(1,1,1,1,2),pord)
      ! ncut = lx1-2
      ! if(pord.ne.1) call cut_off_filter(prext,ncut,1)

      ntlsr = uparam(1) !freq of TLS re-distancing
      nclsr = uparam(2) !freq of CLS re-distancing

      call LS_default_driver(ntlsr,nclsr)

      return
      end
c-----------------------------------------------------------------------
      subroutine userqtl ! Set thermal divergence

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat()   ! This routine to modify element vertices
      implicit none

      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2()  ! This routine to modify mesh coordinates
      implicit none

      include 'SIZE'
      include 'TOTAL'
      include 'USRLS'

      integer ie, ifc

      ifld_cls = 2
      ifld_tls = 3
      ifld_clsr = 4
      ifld_tlsr = 5

      do ie=1,nelv
        do ifc=1,2*ndim
          if(bc(5,ifc,ie,1).eq.250)then !injector
            cbc(ifc,ie,1) = 'v  '
            cbc(ifc,ie,ifld_cls) = 't  '
            cbc(ifc,ie,ifld_tls) = 'I  '
            cbc(ifc,ie,ifld_clsr) = 't  '
            cbc(ifc,ie,ifld_tlsr) = 'I  '
            boundaryID(ifc,ie) = 1
            boundaryIDt(ifc,ie) = 1
          elseif(bc(5,ifc,ie,1).eq.251)then !air inlet
            cbc(ifc,ie,1) = 'v  '
            cbc(ifc,ie,ifld_cls) = 't  '
            cbc(ifc,ie,ifld_tls) = 'I  '
            cbc(ifc,ie,ifld_clsr) = 't  '
            cbc(ifc,ie,ifld_tlsr) = 'I  '
            boundaryID(ifc,ie) = 2
            boundaryIDt(ifc,ie) = 2
          elseif(bc(5,ifc,ie,1).eq.252)then !x-outlet
            cbc(ifc,ie,1) = 'O  '
            cbc(ifc,ie,ifld_cls) = 'I  '
            cbc(ifc,ie,ifld_tls) = 'I  '
            cbc(ifc,ie,ifld_clsr) = 'I  '
            cbc(ifc,ie,ifld_tlsr) = 'I  '
            boundaryID(ifc,ie) = 7
            boundaryIDt(ifc,ie) = 7
          elseif(bc(5,ifc,ie,1).eq.253)then !side 1
            cbc(ifc,ie,1) = 'SYM'
            cbc(ifc,ie,ifld_cls) = 't  '
            cbc(ifc,ie,ifld_tls) = 'I  '
            cbc(ifc,ie,ifld_clsr) = 't  '
            cbc(ifc,ie,ifld_tlsr) = 'I  '
            boundaryID(ifc,ie) = 3
            boundaryIDt(ifc,ie) = 3
          elseif(bc(5,ifc,ie,1).eq.254)then !side 2
            cbc(ifc,ie,1) = 'SYM'
            cbc(ifc,ie,ifld_cls) = 't  '
            cbc(ifc,ie,ifld_tls) = 'I  '
            cbc(ifc,ie,ifld_clsr) = 't  '
            cbc(ifc,ie,ifld_tlsr) = 'I  '
            boundaryID(ifc,ie) = 3
            boundaryIDt(ifc,ie) = 3
          elseif(bc(5,ifc,ie,1).eq.255)then !top
            cbc(ifc,ie,1) = 'SYM'
            cbc(ifc,ie,ifld_cls) = 'I  '
            cbc(ifc,ie,ifld_tls) = 'I  '
            cbc(ifc,ie,ifld_clsr) = 'I  '
            cbc(ifc,ie,ifld_tlsr) = 'I  '
            boundaryID(ifc,ie) = 4
            boundaryIDt(ifc,ie) = 4
          elseif(bc(5,ifc,ie,1).eq.256)then !bottomwall
            cbc(ifc,ie,1) = 'W  '
            cbc(ifc,ie,ifld_cls) = 'I  '
            cbc(ifc,ie,ifld_tls) = 'I  '
            cbc(ifc,ie,ifld_clsr) = 'I  '
            cbc(ifc,ie,ifld_tlsr) = 'I  '
            boundaryID(ifc,ie) = 5
            boundaryIDt(ifc,ie) = 5
          elseif(bc(5,ifc,ie,1).eq.257)then !injector walls
            cbc(ifc,ie,1) = 'W  '
            cbc(ifc,ie,ifld_cls) = 't  '
            cbc(ifc,ie,ifld_tls) = 'I  '
            cbc(ifc,ie,ifld_clsr) = 't  '
            cbc(ifc,ie,ifld_tlsr) = 'I  '
            boundaryID(ifc,ie) = 6
            boundaryIDt(ifc,ie) = 6
          endif
        enddo
      enddo


      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3()
      implicit none

      include 'SIZE'
      include 'TOTAL'
      include 'SVV'
      include 'USRLS'

      real eps,dt_cls_in,dt_tls_in
      integer nsteps_cls, nsteps_tls

      integer ifdebug, ifixCLSbdry
      real farfield

      eps = 2.0/(lx1-1.0)
      ifdebug = 0
      ifixCLSbdry = 0
      farfield = 0.0
      call ls_init(ifld_cls, ifld_clsr,
     $             ifld_tls, ifld_tlsr,
     $             eps, ifdebug, ifixCLSbdry, farfield)

c---------------------------------------------------      
c     This section to specify user defined parameters
c     for AVM/SVV. Leave commented to use default parameters
c     parameters. 

      !fluid
      svv_c0(1) = 1.0
      svvcut(1) = (lx1-1.0)/2.0

      svv_c0(ifld_cls) = 1.0                 !ifld_cls
      svvcut(ifld_cls) = (lx1-1.0)/2.0
      ! svv_k0(1) = 1.5
      ! svv_k1(1) = 1.5
      ! ifnlsvv(1) = .true.

      ! avm_c1(1) = 1.0
      ! avm_ncut(1) = 1.0
      ! icont(1) = .false.
      ! ifupwindsvv(ifld_cls) = .true.

c     scalar 2      
      svv_c0(ifld_tls) = 1.0                  !ifld_tls
      svvcut(ifld_tls) = (lx1-1.0)/2.0
      ! svv_k0(2) = 1.5
      ! svv_k1(2) = 1.5
      ! ifnlsvv(2) = .false.
      ! ifupwindsvv(ifld_tls) = .true.

c     scalar 3      
      svv_c0(ifld_clsr) = 1.0                  !ifld_clsr
      svvcut(ifld_clsr) = (lx1-1.0)/2.0
      ! svv_k0(3) = 1.5
      ! svv_k1(3) = 1.5
      ! ifnlsvv(3) = .false.
      ! ifupwindsvv(ifld_clsr) = .true.

c     scalar 3      
      svv_c0(ifld_tlsr) = 2.0                  !ifld_tlsr
      svvcut(ifld_tlsr) = (lx1-1.0)/2.0
      if(lx1.gt.7) svvcut(ifld_tlsr) = (lx1-1.0)/3.0
      ! svv_k0(4) = 1.5
      ! svv_k1(4) = 1.5
      ! ifnlsvv(4) = .false.
      ! ifupwindsvv(ifld_tlsr) = .true.

      return
      end
c---------------------------------------------------------------------
